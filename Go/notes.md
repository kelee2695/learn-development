# go语言环境
go工具链以可执行程序的形式发布

```bash
##可下载得到go1.4.linux-amd64.tar.gz
##将压缩包解压进入/usr/local文件夹，得到/usr/local/go文件夹，其中go可执行程序放置在/usr/local/go/bin文件夹下
tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz
##将/usr/local/go/bin文件夹加入PATH环境变量，此时可以在用户各处使用go可执行程序
export PATH=$PATH:/usr/local/go/bin
##刷新环境变量文件，启用新环境变量
source ~/.bash_profile
```

# go语言结构
## go语言项目构成
go语言项目由一个一个的包组成。
在go语言的项目中，一个文件夹下的所有go文件应该属于同一个包。
文件夹名与包名建议保持一致（不强制）。
文件夹名与包名应全小写，尽量避免下划线驼峰式等命名方式。
每一个项目有一个main包，是程序的入口。
## go语言包构成
go语言的一个包由多个源文件组成。
每一个包可以有一个或多个init函数。
init函数在包被导入时运行，用于包的初始化，初始化完成后才会进入项目的main函数。
多个源文件中存在init函数时，通过源文件名的字母序决定init函数运行的顺序。
main包中会有main函数，用于作为项目的总入口。
## go语言源文件构成
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```
包声明：声明本源文件属于哪一个包。
包引入：引入别的包
函数：
变量：
语句与表达式：
注释：
## 执行go文件
```bash
##直接运行main.go
go run main.go
##将main.go编译为一个可执行文件
go build main.go
###存在多个源文件运行
go run main.go helper.go utils.go
go run .
go run *.go
###存在多个源文件需要编译
go build main.go helper.go utils.go -o myapp
go build -o myapp
```
当想把项目变成可执行文件时，只需要编译main包。
# go语言基本语法
## 行分隔符
go语言以换行代表一个语句的结束。
若语句写在同一行，则需要使用;分隔语句。
go语言编译器不要求语句的缩进，但是良好的缩进有助于阅读与协作。
## 注释
```go
// 单行注释

/*
多行注释
*/
```
## 关键字
下面列举了 Go 代码中会使用到的 25 个关键字或保留字：
| 关键字 | 描述 |
| --- | --- |
| break | 结束当前循环或语句 |
| default | 默认情况 |
| func | 定义函数 |
| interface | 定义接口 |
| select | 选择语句 |
| case | 开关语句的情况 |
| defer | 延迟执行函数 |
| go | 启动新的 goroutine |
| map | 定义映射 |
| struct | 定义结构体 |
| chan | 定义通道 |
| else | 否则 |
| goto | 跳转 |
| package | 定义包 |
| switch | 开关语句 |
| const | 定义常量 |
| fallthrough | 继续执行下一个 case |
| if | 如果 |
| range | 遍历 |
| type | 定义类型 |
| continue | 继续下一次循环 |
| for | 循环 |
| import | 导入包 |
| return | 返回 |
| var | 定义变量 |
除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：
| 预定义标识符 | 描述 |
| --- | --- |
| append | 追加元素到切片 |
| bool | 布尔型 |
| byte | 无符号 8 位整型 |
| cap | 容量 |
| close | 关闭通道 |
| complex | 复数 |
| complex64 | 64 位复数 |
| complex128 | 128 位复数 |
| uint16 | 无符号 16 位整型 |
| copy | 复制元素到切片 |
| false | 布尔型的 false 值 |
| float32 | 32 位浮点数 |
| float64 | 64 位浮点数 |
| imag | 取复数的虚部 |
| int | 有符号 32 位整型 |
| int8 | 有符号 8 位整型 |
| int16 | 有符号 16 位整型 |
| uint32 | 无符号 32 位整型 |
| int32 | 有符号 32 位整型 |
| int64 | 有符号 64 位整型 |
| iota | 枚举常量 |
| len | 长度 |
| make | 创建 |
| new | 分配内存 |
| nil | 空值 |
| panic | 恐慌 |
| uint64 | 无符号 64 位整型 |
| print | 打印 |
| println | 打印并换行 |
| real | 取复数的实部 |
| recover | 恢复 |
| string | 字符串 |
| true | 布尔型的 true 值 |
| uint | 无符号 32 位整型 |
| uint8 | 无符号 8 位整型 |
| uintptr | 无符号指针整型 |

程序一般由关键字、常量、变量、运算符、类型和函数组成。
程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。
程序中可能会使用到这些标点符号：.、,、;、: 和 …。
# Go 语言数据类型
在 Go 编程语言中，数据类型用于声明函数和变量。
数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。
## Go 语言基本数据类型
| 序号 | 类型和描述 |
| --- | --- |
| 1 | 布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 |
| 2 | 数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 |
| 3 | 字符串类型 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 |
### 数字类型
#### 整型
| 序号 | 类型和描述 |
| --- | --- |
| 1 | ​uint8​ 无符号 8 位整型 (0 到 255) |
| 2 | ​uint16​ 无符号 16 位整型 (0 到 65535) |
| 3 | ​uint32​ 无符号 32 位整型 (0 到 4294967295) |
| 4 | ​uint64​ 无符号 64 位整型 (0 到 18446744073709551615) |
| 5 | ​int8​ 有符号 8 位整型 (-128 到 127) |
| 6 | ​int16​ 有符号 16 位整型 (-32768 到 32767) |
| 7 | ​int32​ 有符号 32 位整型 (-2147483648 到 2147483647) |
| 8 | ​int64​ 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) |

#### 浮点型
| 序号 | 类型和描述 |
| --- | --- |
| 1 | ​float32​ IEEE-754 32位浮点型数 |
| 2 | ​float64​ IEEE-754 64位浮点型数 |
| 3 | ​complex64​ 32 位实数和虚数 |
| 4 | ​complex128​ 64 位实数和虚数 |

#### 其他数字类型
| 序号 | 类型和描述 |
| --- | --- |
| 1 | ​byte​ 类似 uint8 |
| 2 | rune​ 类似 int32 |
| 3 | ​uint​ 32 或 64 位 |
| 4 | ​int​ 与 uint 一样大小 |
| 5 | ​uintptr​ 无符号整型，用于存放一个指针 |
## Go 语言引用数据类型
| 序号 | 类型与描述 |
| --- | --- |
| 1 | 指针类型（Pointer），指针类型指向内存中的一个地址，用于存储变量的内存地址。 |
| 2 | 数组类型，数组是相同类型元素的集合，每个元素都有一个唯一的索引。 |
| 3 | 结构化类型(struct)，结构体是一种用户自定义的聚合数据类型，用于存储不同类型的字段。 |
| 4 | Channel 类型，Channel 是一种用于在 goroutine 之间通信的类型，用于发送和接收数据。 |
| 5 | 函数类型，函数类型是一种特殊的类型，用于表示函数的签名（参数类型和返回值类型）。 |    
| 6 | 切片类型，切片是一种动态数组，长度可以改变，用于存储相同类型的元素。 |
| 7 | 接口类型（interface），接口类型是一种抽象类型，用于定义方法的集合。 |
| 8 | Map 类型，Map 是一种无序的键值对集合，用于存储键值对。 |

引用类型（Reference Types）
引用类型的特点是变量内部存储的是指向底层数据结构的指针（内存地址），而不是数据本身。当你复制一个引用类型变量或将其传递给函数时，复制的仅仅是这个指针，多个变量会共享同一份底层数据。因此，通过任何一个变量修改底层数据，其他所有引用该数据的变量都会"看到"这个变化。
常见引用类型：包括切片（slice）、映射（map）、通道（channel）、接口（interface）、函数（func）以及指针（pointer）本身。
内存分配：引用类型的数据（底层数组、哈希表等）通常分配在堆上，由 Go 的垃圾回收器（GC）管理其生命周期。引用类型变量本身（存储指针的那个变量）通常在栈上。
初始化：引用类型的零值通常是 nil，表示尚未指向任何有效数据结构。对于 slice、map 和 channel，通常需要使用内置的 make 函数进行初始化，make 会分配内存并设置好内部结构，使其立即可用。直接对 nil 的引用类型进行操作（如向 nil map 赋值）会引发运行时 panic。
# go语言变量
## 变量作用域
Go 语言中变量的作用域由其声明位置决定：
包级变量（全局变量）：在函数体外声明，在整个包内可见。
局部变量：在函数或代码块（如 if, for 内部的 {}）内声明，仅在其所在块内可见。
变量遮蔽发生在内部作用域中声明了与外部作用域同名的变量时，这可能导致意外的行为。
## 变量声明
在 Go 语言中，所有声明了的变量都会立即被初始化。如果你没有显式地给它赋值，Go 会自动为其赋予一个默认值，这个默认值就是该类型的零值（Zero Value）。
Go 语言中的零值初始化机制确实会在变量声明时为其赋予一个默认值，你可以将其理解为一种语言内置的、自动运行的"默认无参初始化"。
对于结构体等复合类型，其零值初始化是递归（recursive） 的，即所有字段都会被设置为各自类型的零值。
```go
type Person struct {
    Name string
    Age  int
}
var p Person // p.Name 为 "", p.Age 为 0
```
### 变量声明方式一览表
```go​
// var基本声明​
var age intvar name = "Alice"
// 包级变量、需要显式类型或延迟初始化时
// 未初始化则赋予零值​
```
```go​
// 短变量声明 (:=)​​
count := 10
// 函数内部的局部变量
// 左侧至少有一个新变量
```
```go​
// 多变量声明​
var a, b, c intvar x, y = 1, 2.5
同时声明多个变量
类型可以相同或不同
```
```go​
// 批量声明​
var ( name string age int )
// 声明多个包级变量，代码更清晰
```